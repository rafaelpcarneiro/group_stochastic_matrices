# Group of stochastic matrices 

Given a group of stochastic matrices G with real entries, i.e.,
a subgroup of the general linear group GL_n (group that all 
nxn matrices are invertible) whose all rows sum to 1, 
I am interested to check if
such group G has a tangent space T_1(G), which is a Lie algebra, that is
semisimple or at least it has a subalgebra that is semisimple.

The following scripts are going to check such properties.

## First Script: check_semi_simple.m

*Description*: Given the group G, described as above, it's easy to check
that it has a tangent space T_1(G) defined by all matrices nxn 
such that all rows sum to zero. 
Now, in order to check if T_1(G) is a semi-simple Lie algebra, we
calculate its killing form, named as K. Given the killing form,
we only need to observe that the quadratic matrix associated to this form  
is invertible, or, in other words, we inspect if this matrix is full rank.
The script **check_semi_simple** does exactly this idea, it ask the user
to define the dimension of the stochastic matrices that define the group
G and returns as output a message saying that the tangent space is 
a semisimple algebra or not and, in case the user desires to check 
the killing form, it returns the matrix of the killing form.

## Second Script: simulacao.m
*Description*: Here I fix the group G of stochastic matrices as the group
of the quadratic 3x3 matrices. Unfortunately, this group has a tangent
space T_1(G) which is not semisimple. However, T_1(G) is not solvable
and I have found an ideal that is sovable. By the Levi's Theorem, I know
that exists a subalgebra of T_1(G) which is semisimple.

Having that in mind, the script **simulacao.m** try to find a subalgebra
of T_1(G) that is semisimple. Unfortunately, the way I solve
this problem is by brute force which demands a lot of computation
and it takes a lot of time. In general, the program does the following:
given a base B_1 of the solvable ideal it guess a base B_2,
such that B_1 union B_2 generates T_1(G), and it checks if the algebra
generated by B_2 is semisimple.
The procedure of guessing the base B_2 is horrible because such set has 
infinite possibilities. But, luckily, the desired base happen to be in
the set of the basis that I was looking for. At the end, the program prints
the desired base at a txt file.

